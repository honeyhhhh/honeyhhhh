<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线性表的链式存储结构（一）：单链表]]></title>
    <url>%2Flink%2F</url>
    <content type="text"><![CDATA[什么是线性表(List)简单来说，就是线一样的结构定义：由零个或多个数据元素组成的有序序列特点： 有序 有限 若将线性表记为(a1,a2.ai-1,ai,ai+1…an);则ai-1称为ai的直接前驱元素，ai+1称为ai的直接后继元素，第一个元素无前驱，最后一个元素无后继，当n=0时，称为空表。 线性表的顺序存储结构粗略提一下，线性表的两种存储结构之顺序存储结构，其实跟 数组长的一毛一样，其实也不算一毛一样，这以后再说。定义：用一段地址连续的存储单元依次存储线性表的数据结构 链表线性表的链式存储结构特点是用一组任意存储单元存储线性表的数据元素，这组存储单元可以在内存中未被占用的任意位置。 结点(Node):结点由两部分组成，用来存储数据元素信息的域称为数据域，存储直接后继位置的称为指针域。指针域中存储的信息称为指针或者链。 n个结点链接成的一个链表，即为线性表(a1,a2…an)的链式存储结构。 单链表:每个结点只包含一个指针域。 对于线性表来说，有头有尾，链表也不例外。链表中的第一个结点的存储位置叫做头指针，最后一个结点指针为空(NULL)。 头指针和头结点的异同 头指针 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 头指针具有标识作用，所以常用头指针冠以链表的名字(指针变量的名字) 头指针是链表的必要元素，无论链表是否为空，头指针均不为空。 头结点 头结点是为了操作统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义，但也可以用来存储链表的长度 有了头结点，对放在第一个元素结点前插入结点和删除第一个结点和其他结点的操作就统一了。没有头结点，在进行一些操作时通常要对头指针进行修改。 头结点不是链表的必要元素 单链表存储结构图片后面有～ 假设p是指向线性表第i个元素的指针，则该结点ai的数据域可以用p-&gt;date的值表示，结点ai的指针域可以用p-&gt;next表示，p-&gt;next的值是一个指针。 p-&gt;next指向的是i+1个元素！！也就是指向ai+1的指针。 内存池用malloc函数申请堆内存时，由于所申请内存块大小不定，当使用频繁时会造成大量内存碎片，而内存池的作用就是将这些碎片保存，等到想用了在拿出来。其实free函数也是这样，free 函数选择创建一个内存池，将这些“废弃”的内存块搁在一起，等再次调用 malloc 函数申请内存的时候，先在空闲区块链表里面找找看有没有可用的内存块，有的话直接拿出来用，没有的话才申请个新的。所以好处就是能够尽量避免内存碎片，使内存分配效率得到提升。下面的我将使用==单链表==来维护一个内存池，涉及到创建，插入，删除。 单链表的操作:插入，删除，创建，逆置，排序不多bb，直接上代码，还有纯手工图片。假设这是一个通讯录吧，!!!!下面的单链表没有头结点的!!!!,我觉得没有头结点的链表比较直观，但是在删除等操作起来确实有点麻烦。。 12345678910111213struct contacts&#123; char name[20]; char phone[20]; struct contacts *next;&#125;;struct pool = NULL;//内存池创建int count;//默认值为0，记录个数int main(void)&#123; struct contacts *head = NULL;//头指针&#125; 头插法建立单链表123456789101112131415161718192021222324252627282930313233void addPersion(struct contacts **head)//传进来头指针的地址，修改头指针的指向&#123; struct contacts *person,*temp; if(pool!=NULL)//如果内存池不为空，则从中取出，下同 &#123; person=pool; pool=pool-&gt;next; count--; &#125; else &#123; person = (struct contacts *)malloc(sizeof(struct contacts)); if (person == NULL)//内存分配失败 &#123; exit(1); &#125; &#125; getInput(person);//再写一个函数填充信息 //重点！ if(*head != NULL)//非空链表 &#123; temp = *head; *head = person; person-&gt;next = temp; &#125; else//空链表 &#123; *head = person; person-&gt;next = NULL; &#125;&#125; 尾插法建立单链表123456789101112131415161718192021222324252627282930313233void addPerson(struct contacts **head)&#123; static struct contacts *tail;//tail永远在链表尾部，需要用static静态局部变量 struct contacts *person; if(pool!=NULL) &#123; person=pool; pool=pool-&gt;next; count--; &#125; else &#123; person = (struct contacts *)malloc(sizeof(struct contacts)); if (person == NULL) &#123; exit(1); &#125; &#125; getInput(person); //重点！！ if(*head != NULL) &#123; tail-&gt;next=person; person-&gt;next=NULL; &#125; else &#123; *head=person; person-&gt;next=NULL; &#125; tail=person;//将插入的结点设置为新的tail&#125; 提一下这个尾插法,仅仅适用与建立空链表。。在做题过程中发现把上面的NULL换成*head，就建立了循环链表，而尾插法是不改变插入顺序的。再提一下建立链表的方法吧，我看过其他的建立链表的方法，其实每个人都有自己的方法，我的也不一定是最好的，但一定是我所能理解的，还有就是有无头结点，还是那句话，适合自己的才是最好的。世界上也没有最好的算法，应尽力做到时空均衡。如果要有有头结点的话，就给头指针分配一个内存空间，head-&gt;next就是第一个元素，就可以采用循环来建立链表了 单链表的遍历1234567891011void displayContacts(struct contacts *head)&#123; struct contacts *person; person = head; while (person != NULL)//判断为空条件！！ &#123; printPerson(person);//再写一个函数输出信息 person=person-&gt;next; &#125;&#125; 单链表的查找查找一般是为了删除和修改，修改就不说了，找到直接改。123456789101112struct contacts *findPerson(struct contacts *head)//返回结点指针&#123; struct contacts *current; char input[40]; scanf("%s",input);//你所要查找的数据信息 current = head; while (current!=NULL &amp;&amp; strcmp(current-&gt;name, input)) &#123; current=current-&gt;next; &#125; return current;&#125; 单链表的排序排序涉及到好多排序，冒泡希尔插入选择等等，快速排序可以选择第一个元素和最后一个元素，为中间值。一旦涉及到排序就免不了交换，而这里的交换不是交换结点，而是只交换数据域，有一次我就是傻傻的把结点给交换了，却不知道里面还有个指针域。。但是我在大佬的博客看到真有交换结点的，值的琢磨。12void bubble_sort(struct contacts **head)//冒泡排序void select_sort(struct contacts **head)//选择排序 这个暂时不会 重点 还是得bb几句有无头结点的链表 有头结点的链表：第一个结点只有指针域，该指针域存放的是指向链表下一个结点的指针(或者NULL)，该链表通过头结点标记。 无头结点的链表：第一个结点既有数据域又有指针域，是通过一个指向该链表第一个结点的指针来标记该链表的。 有头结点的单链表肯定是比较好理解的，但它也会浪费一点资源。无头结点就是代码有点恐怖而已，这也是我排序算法不敢写下去的原因之一，但其中的好处也是有的，比如连接两个链表有头结点的链表实现了算法的统一。 链表的插入思路：因为是链式结构，一环扣一环，往前走就回不去了，所以一般情况下我们得记录前一个结点。。假如你要在p,p-&gt;next之间插入s，则有s-&gt;next = p-&gt;next;p-&gt;next = s;两者不可调换。123456789101112131415161718192021void insertPerson(struct contacts **head)&#123; struct contacts *previons = NULL; struct contacts *current; struct contacts *new; //new新结点 while(current != NULL &amp;&amp; (这里定位)) &#123; previous = current; current = current-&gt;next; &#125; new-&gt;next = current; if(previons = NULL)//空链表 &#123; *head = new; &#125; else &#123; previous-&gt;next = new; &#125;&#125; 单链表的删除思路：一般情况下，还是要记录前一个结点，但是特殊情况下比如你已经排过序了，你已经知道你要删除的是你当前结点的下一个结点，就不用那么麻烦了，这种情况就不说了，自己图一画就可以了,大概就是p-&gt;next = p-&gt;next-&gt;next; 1234567891011121314151617181920212223242526272829303132333435363738394041void delPerson(struct contacts **head)&#123; struct contacts *temp; struct contacts current = *head;//记录当前结点 struct contract previous = NULL;//记录前一个结点 //假设你要删除的是person结点 //加一个判断person是否为NULL，不是执行下面语句 while (current != NULL &amp;&amp; current != person) &#123; previous = current; current = current-&gt;next; &#125; if (previous == NULL)//待删除的为第一个结点 &#123; *head = current-&gt;next; &#125; else &#123; previous-&gt;next = current-&gt;next; &#125; //判断内存池是否有空间，有的话把删除的结点放入内存池 if(count &lt; MAX) &#123; if(pool != NULL) &#123; temp = pool; pool = person; person-&gt;next = temp; &#125; else &#123; pool = person; person-&gt;next = NULL; &#125; count++; &#125; else &#123; free(person);//直接释放 &#125;&#125; 插入和删除的思想是相通的，都要经过遍历。 单链表的释放(整表删除),内存池的释放12345678910void releaseContacts(struct contacts **head)//内存池同理，只是参数为空&#123; struct contacts *temp; while (*head!=NULL) &#123; temp=*head; *head=(*head)-&gt;next;//*优先级低于-&gt; free(temp); &#125;&#125; 单链表的逆置把图画出来就就简单多了,代码简单，有么有bug我也不知道，反正是我参照别人的图自己写的。。 12345678910111213void invertContacts(struct contacts **head)&#123; //省去判断是否为空链表和一个元素的链表 struct contacts *p=*head,*q;//p指向第一个结点 *head=NULL;//断开头指针与第一个结点的联系 while(p) &#123; q=p-&gt;next; p-&gt;next=*head; *head=p; p=q; &#125;&#125; 单链表结构与顺序存储结构的优缺点 时间性能 查找 顺序结构O(1) 单链表O(n) 插入和删除 顺序结构需要平均移动表长一半的元素，时间O(n) 单链表在计算出某位置的指针后（前提），时间O(1) 空间性能顺序结构需要与分配存储空间，而单链表不需要 综上所述，各有其优缺点，对于插入和删除数据越频繁的操作，单链表的效率优势越明显。比如要从第i个位置开始插入连续10个元素，对于顺序存储结构来说每次插入都要要移动n-i个位置，每次都是O(n),而单链表，只需要在第一次找到第i个位置O(n),接下去只是简单移动指针O(1)。 心得体会其实你只要会画图，用你学习链表的方式画出链表，所有的问题都不算什么，多动笔 如有错误，欢迎指正]]></content>
      <categories>
        <category>数据结构与算法 - 线性表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello myblog!]]></title>
    <url>%2Fdiary181228%2F</url>
    <content type="text"><![CDATA[人生在勤，不索何获？ 经过了五天的努力，我的博客基本搭建好了，虽然在移动端还是有一些不尽人意，但我还挺满足的，毕竟自己也不是学前端的。搭这个博客我还是很纠结的，因为实际上搭博客我只花了一天，已经可以实现它的功能了，但是我想让它好看一点。爱美之心人皆有之，紧接着，我看到了许多优秀的大佬的作品，实在是非常喜欢，于是我便沉迷了。我很矛盾，因为离期末考也就十几天，然而我心里并没有底，而且我还有好多事情没干。时间过的很快，一学期就要过去了，可是我早睡早起的目标依旧没有实现，我也相信这是很多人的目标，所以这也是我寒假的目标，而我现在的目标便是做好现在该做的事，具体是啥事我一时也说不会出来。接下去我会找个时间记录我这几天的辛酸….感觉自己过的很充实，但又害怕把时间用错地方。。。。。最后，纪念一下我的生日，就在刚刚过去不久的昨天，还有过去也不久的前天（农历）哈哈哈哈哈。]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test2]]></title>
    <url>%2Ftest2%2F</url>
    <content type="text"></content>
      <categories>
        <category>test1</category>
      </categories>
      <tags>
        <tag>test1</tag>
        <tag>test2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Ftest%2F</url>
    <content type="text"></content>
      <tags>
        <tag>test1</tag>
        <tag>test2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
